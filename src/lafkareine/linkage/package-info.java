/** 表計算ソフトの自動再計算機能のようなものを提供します。
 *
 * 変数同士の依存関係を定義することで、依存元が変更されたときに、それに依存先の変数の再評価を行わせることができます。
 * Subjectの状態に対する自身の状態を関数従属的に定義することで、副作用の影響を受けにくくすることができます。
 *
 * これは、Observerが複数のSubjectを監視できるよう拡張されたObservableパターンとしても説明できます。
 *
 *
 * 利用者が明示的にadd/deleteObserverを行う必要はありません。
 *
 * このシステムはObservableパターンの派生なので、SubjectとObserverは相互参照を持ちます。
 * そのため、不要になったObserverをSubjectから適切に破棄させないと、メモリリークを起こしてしまいます。
 * しかし、Observerが不要になったかどうかの判断を利用者が行うのは難しく、C++のメモリ管理と同様の負担を強いることになります。
 * この問題について、ここでは弱参照を利用することで対処しています。SubjectからObserverへのリンクは弱参照により保持されており、Observerへ他所からの強参照が無くなった時点でObserverはGCによる回収が可能になります。
 * 逆に、Subject以外のどこからも参照されなくなったLinkableオブジェクトは自然に消滅してしまうため、通常のObserverのように扱う場合であっても、あえて強参照を残しておく必要があります。
 *
 *
 * Linkableは、通常の変数を拡張するようにして使うことができ、最も頻繁に使用され、Linkableなプログラミングの中核を担います。
 * Readonlyは、一度だけ値または式を書き込むことができ、一度決定された値は二度と書き換わらないことが保証されています。final変数のようにして扱うことができます。
 * Pathは、あるLinkableBaseのインスタンスと、そこに含まれるLinkableBaseのインスタンスの両方を監視したい場合に使います。
 * Wrapは、Linkableへの参照を持ち、参照先の値が変わるか、参照先が変わったときに、変更を通知します
 * Activeは、値を持たず、イベントハンドラとしてのみ活用されるものを示します
 * Triggerは、無条件にイベントを発生させることができます
 * Actionは、通常のイベントリスナのように、イベントによって対応するアクションを実行します
 * Censorは、以前のget()の以降にイベントが発生したかどうかを検出します
 * Shiftは、効率的に依存元を切り替えるためのメカニズムを提供します
 *
 * @author teneur lafkareine */

package lafkareine.linkage;